{"meta":{"title":"Lee's Blog","subtitle":"","description":"","author":"unknown","url":"http://ctrl98.github.io","root":"/"},"pages":[{"title":"All categories","date":"2020-02-25T04:47:45.380Z","updated":"2020-02-25T04:47:45.380Z","comments":true,"path":"categories/index.html","permalink":"http://ctrl98.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-02-25T04:54:31.018Z","updated":"2020-02-25T04:54:31.018Z","comments":true,"path":"about/index.html","permalink":"http://ctrl98.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-25T04:55:08.804Z","updated":"2020-02-25T04:55:08.804Z","comments":true,"path":"tags/index.html","permalink":"http://ctrl98.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis数据缓存 基础知识","slug":"Redis1","date":"2020-03-06T01:12:22.000Z","updated":"2020-03-06T11:37:00.335Z","comments":true,"path":"2020/03/06/Redis1/","link":"","permalink":"http://ctrl98.github.io/2020/03/06/Redis1/","excerpt":"","text":"主流应用架构 穿透查询：请求数据的时候先到缓存层查询数据，当缓存层没有数据，在穿透到存储层查询 回种：穿透查询完成后再缓存到缓存区 熔断：当存储层挂了之后，会自动从缓存层获取并返回数据，无论有没有获取到数据都返回 缓存中间件——Memcache和Redis的区别 Memcache：代码层次类似Hash 优缺点： 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片(把数据库打碎的过程，将大数据分布到各个物理节点上) Redis 优缺点： 数据类型丰富 支持数据持久化存储 支持主从 支持分片(3.0版本后) 为什么Redis能这么快？ 100000+QPS（QPS即query per second，每秒内查询次数） 完全基于内存，绝大部分请求时纯粹的内存操作，执行效率高 数据结构简单，对数据操作也简单 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例 使用多路复用I/O复用模型，非阻塞IO redis安装及配置 本地安装redis服务 进入根目录，配置redis.windows.conf： 添加配置需要密码验证 requirepass 123456 修改 appendonly 为yes 开启aof日志防止数据丢失 根目录处以管理员身份打开cmd 输入启动命令启动服务端： 12.\\redis-server.exe redis.windows.conf###注意如果提示错误，把前面的.\\请去掉再回车试试 再打开一个cmd窗口启动客户端： 1.\\redis-cli.exe 然后输入认证密码命令连接服务： 1auth 123456 显示ok即连接成功，输入ping测试看是否返回pong。 Redis数据类型 String类型 redis最基本的数据类型，k-v存储，最大能存储512M，二进制安全(即可以包含任何数据，如jpg图片、序列化对象…) 简单操作 1234567891011121314151617127.0.0.1:6379&gt; set name &quot;redis&quot;OK127.0.0.1:6379&gt; get name&quot;redis&quot;127.0.0.1:6379&gt; set name &quot;memocache&quot;OK127.0.0.1:6379&gt; get name&quot;memocache&quot;127.0.0.1:6379&gt; set count 1OK127.0.0.1:6379&gt; get count&quot;1&quot;127.0.0.1:6379&gt; incr count(integer) 2127.0.0.1:6379&gt; get count&quot;2&quot;127.0.0.1:6379&gt; Hash类型 string元素组成的字典，适合用于存储对象 简单操作 1234567891011127.0.0.1:6379&gt; hmset lilei name &quot;lilei&quot; age 18 title &quot;senior&quot;OK127.0.0.1:6379&gt; hget lilei age&quot;18&quot;127.0.0.1:6379&gt; hget lilei title&quot;senior&quot;127.0.0.1:6379&gt; hset lilei title &quot;collge&quot;(integer) 0127.0.0.1:6379&gt; hget lilei title&quot;collge&quot;127.0.0.1:6379&gt; List类型 列表，按照String元素插入顺序排序，可以添加元素到列表的头部或尾部，元素先进后出，(最新排行榜) 简单操作 1234567891011127.0.0.1:6379&gt; lpush mylist aaa(integer) 1127.0.0.1:6379&gt; lpush mylist bbb(integer) 2127.0.0.1:6379&gt; lpush mylist ccc(integer) 3127.0.0.1:6379&gt; lrange mylist 0 101) &quot;ccc&quot;2) &quot;bbb&quot;3) &quot;aaa&quot;127.0.0.1:6379&gt; Set类型 String元素组成的无须集合，通过哈希表表现，不允许重复，(微博的互相关注) 简单操作 12345678910111213141516171819202122232425262728127.0.0.1:6379&gt; sadd myset 111(integer) 1127.0.0.1:6379&gt; sadd myset 222(integer) 1127.0.0.1:6379&gt; sadd myset 333(integer) 1127.0.0.1:6379&gt; sadd myset 333(integer) 0127.0.0.1:6379&gt; smembers myset1) &quot;111&quot;2) &quot;222&quot;3) &quot;333&quot;127.0.0.1:6379&gt; sadd myset abc(integer) 1127.0.0.1:6379&gt; sadd myset abd(integer) 1127.0.0.1:6379&gt; sadd myset abb(integer) 1127.0.0.1:6379&gt; sadd myset abd(integer) 0127.0.0.1:6379&gt; smembers myset1) &quot;abc&quot;2) &quot;222&quot;3) &quot;abd&quot;4) &quot;abb&quot;5) &quot;333&quot;6) &quot;111&quot;127.0.0.1:6379&gt; Sorted Set类型 通过分数score来为集合中的成员进行从小到大排序，去重 简单操作 12345678910111213141516127.0.0.1:6379&gt; zadd myzset 3 abc(integer) 1127.0.0.1:6379&gt; zadd myzset 1 abd(integer) 1127.0.0.1:6379&gt; zadd myzset 2 abb(integer) 1127.0.0.1:6379&gt; zadd myzset 2 abb(integer) 0127.0.0.1:6379&gt; zadd myzset 1 bgg(integer) 1127.0.0.1:6379&gt; zrangebyscore myzset 0 101) &quot;abd&quot;2) &quot;bgg&quot;3) &quot;abb&quot;4) &quot;abc&quot;127.0.0.1:6379&gt;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ctrl98.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://ctrl98.github.io/tags/Redis/"}]},{"title":"Mysql 基础知识（一）","slug":"Mysql1","date":"2020-03-06T01:05:41.000Z","updated":"2020-03-06T01:07:55.074Z","comments":true,"path":"2020/03/06/Mysql1/","link":"","permalink":"http://ctrl98.github.io/2020/03/06/Mysql1/","excerpt":"","text":"where子句 **where：**数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。 **group by:**对select查询出来的结果集按照某个字段或者表达式进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。 **having：**用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。 执行顺序 select –&gt;where –&gt; group by–&gt; having–&gt;order by update 当我们需要将字段中的特定字符串批量修改为其他字符串时，可已使用以下操作： 12UPDATE runoob_tbl SET runoob_title &#x3D; REPLACE(runoob_title, &#39;C++&#39;, &#39;Python&#39;) where runoob_id &#x3D; 3; delete delete，drop，truncate 都有删除表的作用，区别在于： 1、delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。 2、delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。 3、执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。 like子句 LIKE 子句中使用百分号 **%**字符来表示任意字符，类似于UNIX或正则表达式中的星号 ***** 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 like 匹配/模糊匹配，会与 % 和 _ 结合使用： 123456&#39;%a&#39; &#x2F;&#x2F;以a结尾的数据&#39;a%&#39; &#x2F;&#x2F;以a开头的数据&#39;%a%&#39; &#x2F;&#x2F;含有a的数据&#39;_a_&#39; &#x2F;&#x2F;三位且中间字母是a的&#39;_a&#39; &#x2F;&#x2F;两位且结尾字母是a的&#39;a_&#39; &#x2F;&#x2F;两位且开头字母是a的 union 操作符 UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 union 实例： 1SELECT country FROM Websites UNION SELECT country FROM apps ORDER BY country 查两张表中的同一个字段的不同值都查询出来（去重） union all 实例： 1SELECT country FROM Websites UNION ALL SELECT country FROM apps ORDER BY country 查两张表中的同一个字段的相同的值都查出来（不去重） order by 子句排序 ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，它是按升序排列 。 1SELECT * from runoob_tbl ORDER BY submission_date ASC; 拼音排序 字符集采用的是 gbk(汉字编码字符集) ，直接 order by就行 字符集采用的是 utf8(万国码) ， 先对字段进行转码然后排序 ORDER BY CONVERT(runoob_title using gbk); group up 子句 例如： 将数据表按名字进行分组，并统计每个人有多少条记录 1SELECT name, COUNT(*) FROM employee_tbl GROUP BY name; with rollup 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…） 1SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP; join 连接 需要从多个数据表中读取数据，JOIN 在两个或多个表中查询数据 INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录 比如：读取runoob_tbl表中所有runoob_author字段在tcount_tbl表对应的runoob_count字段值 语法举例：Select A.Name from A INNER JOIN B ON A.id =B.id 1SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author &#x3D; b.runoob_author; 等价于： 1SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author &#x3D; b.runoob_author; **LEFT JOIN（左连接）：**获取左表所有记录，即使右表没有对应匹配的记录 1SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author &#x3D; b.runoob_author; RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录 1SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author &#x3D; b.runoob_author; alter 删除表字段 1ALTER TABLE testalter_tbl DROP i; 添加表字段 1ALTER TABLE testalter_tbl ADD i INT; 修改表字段类型及名称： MODIFY 或 CHANGE 子句 ​ 把字段 c 的类型从 CHAR(1) 改为 CHAR(10) 1ALTER TABLE testalter_tbl MODIFY c CHAR(10); ​ 使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段名及类型 1ALTER TABLE testalter_tbl CHANGE i j BIGINT; 修改表名 1ALTER TABLE testalter_tbl RENAME TO alter_tbl;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://ctrl98.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://ctrl98.github.io/tags/MySQL/"}]},{"title":"Git Bash基础操作","slug":"Git1","date":"2020-03-06T00:48:45.000Z","updated":"2020-03-06T00:59:41.270Z","comments":true,"path":"2020/03/06/Git1/","link":"","permalink":"http://ctrl98.github.io/2020/03/06/Git1/","excerpt":"","text":"Git基本操作 安装： 根据系统自己选择下载傻瓜式安装 配置： 用户名： 1$ git config --global user.name &quot;你的账号&quot; 邮箱： 1$ git config --global user.email &quot;你的邮箱账号&quot; 查看全局配置命令： 1$ cat ~&#x2F;.gitconfig 初始化： 新建一个文件夹，再当前目录下打开git bash 执行命令： 1$ git init 查看状态： 在当前目录新建一个README.md文档； 查看当前git仓库状态： 1$ git status 提交新建文档到缓存区命令： 1$ git add README.md 再次查看当前git仓库状态： 截图中也提示，如果想取消本次提交，可执行： 1$ git rm --cached README.md 提交新文件到暂存区： 提交命令： 1$ git add README.md 当前目录下全部文件都提交： 1$ git add -A 提交新内容到git本地仓库： 提交命令： 1$ git commit -m &quot;add README.md&quot; m：message，输入你本次提交的内容或日志 设置要提交到的远程仓库： 先到自己的github创建新的空白远程仓库； 命令： 1$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;ctrl98&#x2F;git-test.git 查看当前远程仓库的信息： 1$ git remote -v 提交新内容到远程仓库命令： 1$ git push -u origin master 参数说明： -u：第一次提交的时候加上这个属性，以后提交只需要输入：git push即可 -origin：远端链接的名字，创建远程仓库时默认 -master：仓库主干分支 克隆远程仓库项目到本地： 命令： 1$ git clone https:&#x2F;&#x2F;github.com&#x2F;ctrl98&#x2F;git-test.git 更新远程仓库代码到本地： 远程仓库做了修改，本地仓库还是旧的，可执行拉取命令： 1$ git pull Git分支 分支互相独立，互不影响 创建新的分支： 1$ git branch feature1 查看当前分支列表： 1$ git branch 切换分支： 1$ git checkout feature1 查看当前分析目录信息，可发现有master主干上的文件： 在feature1分支下创建a.txt文件，并编辑文件内容：this is a.txt，保存并退出。 commit feature1的文件到本地仓库中。 再创建一个新的分支并切换到该分支： 1$ git checkout -d feature2 查看一下该分支的目录文件信息，发现有master的README.md文档和feature1的a.txt文档，也就是说是基于feature1的，新分支的内容是基于上个分支的内容。 查看文件内容命令： 1$ cat a.txt 分支简单合并 合并命令： 1$ git merge 分支名称 创建并切换到分支feature3: 1$ git checkout -b feature3 新建b.txt文件，并编写内容：hello world： 12touch b.txt;vi b.txt 提交该文件到本地仓库中： 12git add b.txtgit commit -m &quot;add b.txt&quot; 切换回master主分支中： 1$ git checkout master 删除feature3分支： 1$ git branch -d feature3 发现无法删除，因为feature3中本地仓库中有提交，提示你要么合并该分支到master，要么就强制删除分支 合并feature3到master主分支，Head指针执行master： 1$ git merge feature3 提示合并成功 远程仓库创建分支显示 切换到需要再远程仓库中显示的分支： 1$ git checkout feature1 输入设置命令： 1$ git push origin feature1 这个时候远程仓库就会有一个feature1分支显示 也可以起别名： 1$ git push origin feature1:f1 删除远程仓库分支 本地git命令行切换到要删除远程的分支 输入删除命令： 1git push origin :feature1 查看Git日志 命令： 1git log 更简洁地查看： 1git log --oneline 如果提交次数多的话，还可以指定查看最新的提交范围： 1git log --oneline -5 想要查看某一次提交了什么新的内容，可以先复制日志对应的ID，然后执行： 1git show +id 合并操作 清空上面创建的分支，只留下master –ff 方式 创建并切换至f1分支 创建fa.txt文件并提交到本地仓库 查看日志： 1git log --oneline 发现指针HEAD指向了f1 切换回master分支进行合并 (默认使用 --ff 模式) ： 12git checkout mastergit merge f1 此时使用的是 fast-forward 方式合并策略，也就是默认的 --ff 模式，可以通过 git merge --help查看相关模式， 这种方式不会创建一个新的commit，只会显示f1分支提交的message。 –no-ff 方式 保证了原有开发的提交量的完整性 切换回f1分支 创建fb.txt文件并提交到本地仓库： 123touch fb.txtgit add fb.txtgit commit -m &quot;add fb.txt&quot; 切换回master分支进行合并： 12git checkout mastergit merge f1 --no-ff 这个时候会进入一个界面，产生了一条message，叫 Merge branch ‘f1’，我们可以修改这个message，默认不修改，保存退出，这个时候发行合并的策略变为：Merge made by the ‘recursive’ strategy，此时查看log日志会出现拐弯现象，把f1的commit和合并时的message两个commit都显示出来了。 提交到远程仓库，并创建远程仓库分支f1： 12git pushgit push origin f1:f1 打开github的远程仓库，添加master下的a.txt文件内容： 1update 这个时候远程仓库是最新的版本，本地是较旧的版本 回到本地仓库，同步远程master分支的内容到本地： 1git pull 切换到f1分支，f1分支想要拿到master的最新版本，需要merger一下master，才能和master保持同步： 1git merge master 再查看一下日志，发现日志对于本次同步只显示了一条 update a.txt 的信息，并没有出现拐弯 这个时候master有人作了修改，且回到master分支： 12345git checkout mastertouch m1.txtgit add m1.txtgit commit -m &quot;add m1.txt&quot;git log --oneline rebase命令 再回到f1分支，如果我们使用git rebase命令来合并，将f1这个分支移动到master分支的最后一次提交，会把master所有提交并入过来： 12git rebase masterll 再次查看log日志，会发现在f1中会产生一条新的提交，叫&quot;add m1.txt&quot;，重写了项目的提交历史，并且不会带来一条 merge 的commit. rebase最大的好处： 就是使得提交的历史不会出现分叉，项目提交历史看着非常整齐，他不会像 git merge 那样引入一条分叉 **rebase的不好：**安全性和可跟踪性，不要在master上使用rebase命令，rebase命令他不是合并操作，而是复制操作，而merge命令是把两个分支的内容合并到一起。 简单处理合并冲突 在f1分支基础上再创建一个f2分支，并随便修改一下a.txt的内容，保存退出提交到本地仓库： 12git checkout -b f2vi a.txt 回到f1分支，同样修改a.txt文件内容并提交到本地仓库： 12git chrckout f1vi a.txt 再次回到f2分支，这个时候想拉取一下f1同学写的代码： 12git checkout f2git merge f1 这个时候会出现文件冲突，需要解决冲突，查看一下a.txt文件： 1cat a.txt 发现文件内容很乱，显示两个分支上对这个文件的不同修改的内容，要么使用f1的要么使用f2的，然后修改a.txt，就会看到刚才查看到的内容： 1vi a.txt 这样修改很麻烦，实际开发中会用工具下来修改 使用mergetool命令来检测冲突并解决冲突： 1git mergetool 再次回车使用vimdiff来解决冲突，把不需要保留的内容删除，然后保存退出，再看一下a.txt文件： 1cat a.txt 发现内容已经修改为刚才保留下来的内容，然后再commit一下： 1git commit -m &quot;update a.txt&quot; Git的回滚撤销 git reset 分支名^ 回到上一次提交的版本，他只是把HEAD指针移动了，并没有删除东西，默认是–mixed模式（本次提交的东西从暂存区撤销，但仍留在工作区中），在master分支下： 123touch hello.javagit add hello.javagit commit -m &quot;add hello.java&quot; 此时查看log，会发现已经有本条提交记录，这个时候想回退上个版本： 1git reset master^ # ^符号代表上一次的意思 查看状态： 1git status 发现hello.java文件处于未提交状态 同样也可以直接： 1git reset 版本码(查看每条日志前的唯一标识) hard模式简单粗暴，直接还原上个版本的东西，暂存区、工作目录都清空本次更新的内容： 1git reset --hard 版本号 git revert 此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交，用新的commit来回滚上一个版本； 1git revert 版本号 执行后会产生一次commit，填写提交的message，直接保存退出，他就把删除了revert那个版本的东西，比如那次提交是新建了一个文件，执行revert后，那个文件就不存在，但是那次提交commit的message就更新为 revert … 所以，在公共分支上使用 git revert，会把提交的信息记录保存下来，可以回溯，在其他分支，可以直接 git reset回退 Git 工作基本流程 最后附上Git命令大全","categories":[{"name":"Git","slug":"Git","permalink":"http://ctrl98.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://ctrl98.github.io/tags/Git/"},{"name":"版本控制工具","slug":"版本控制工具","permalink":"http://ctrl98.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"}]},{"title":"使用Dockerfile创建镜像","slug":"Docker6","date":"2020-02-27T05:43:51.000Z","updated":"2020-02-27T06:38:09.608Z","comments":true,"path":"2020/02/27/Docker6/","link":"","permalink":"http://ctrl98.github.io/2020/02/27/Docker6/","excerpt":"","text":"什么是Dockerfile文件 Dockerfile文件其实就是一个文本文件，由一系列命令和参数构成，Docker可以读取Dockerfile文件并根据Dockerfile文件的描述构建镜像。 Dockerfile文件内容一般为4个部分 基础镜像信息 维护者信息 镜像操作命令 容器启动时执行的命令 Dockerfile常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 EVN key value 声明环境变量(可以多条) RUN command 是Dockerfile核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和上一条一样，不同的是不自动解压 WORKDIR path_dir 设置工作目录 目标 使用Dockerfile构建一个包含jdk11环境的centos7镜像。 分析： ​ 假设以centos7作为基础镜像，添加jdk11并构建一个包含jdk1.8的centos7新镜像，使用Dockerfile可以实现。 步骤： 拉取centos7镜像 上传jdk11压缩包 编写Dockerfile文件 构建镜像 测试（基于新镜像创建并启动容器，测试jdk版本） 拉取centos7镜像 这个不作过多解释，直接使用 docker pull centos:7命令拉取。 上传jdk文件到宿主机 创建目录： 1mkdir &#x2F;usr&#x2F;local&#x2F;dockerjdk11 使用 WinSCP 软件来上传本地电脑文件到虚拟机centos系统dockerjdk11目录下，也不作过多解释，下载软件后直接输入虚拟机的IP地址，用户名和密码即可登录，端口默认是 22； 编写Dockerfile文件 在/usr/local/dockerjdk11目录下使用vi命令进行编写： 1vi Dockerfile 内容为： 123456789FROM centos:7MAINTAINER 23h59m59sWORKDIR &#x2F;usrRUN mkdir &#x2F;usr&#x2F;local&#x2F;javaADD jdk-11.0.5_linux-x64_bin.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-11.0.5ENV JRE_HOME $JAVA_HOME&#x2F;jreENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATHENV PATH $JAVA_HOME&#x2F;bin:$PATH 按Esc键，然后英文状态下输入 : 键，然后紧接着输入 wq 保存并退出。 构建镜像 输入构建镜像命令： 1docker build -t&#x3D;&#39;jdk11&#39; . -t：要构建的镜像的名称 .：这个点不能省略，表示当前目录下 等到successfully 查看当前镜像列表是否构建成功： 1docker images 测试（基于新镜像创建并启动容器，测试jdk版本） 基于构建的新镜像jdk11创建并启动容器： 1docker run -it --name&#x3D;newtestjdk11 jdk11 &#x2F;bin&#x2F;bash 创建成功后自动进入该容器，测试jdk版本： 1java -version 发现显示jdk的版本为11.0.5","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"Docker容器的备份、迁移与恢复","slug":"Docker5","date":"2020-02-27T04:13:17.000Z","updated":"2020-02-27T05:08:04.763Z","comments":true,"path":"2020/02/27/Docker5/","link":"","permalink":"http://ctrl98.github.io/2020/02/27/Docker5/","excerpt":"","text":"容器的备份、迁移与恢复 其中涉及到的命令： docker commit：将容器保存为镜像 docker save：将镜像备份为tar文件 docker load：根据tar文件恢复为镜像 容器备份 目标：能够将服务器A的某个容器保存为镜像，备份成tar文件，迁移到服务器B恢复镜像再启动以恢复的镜像作为基础的容器来运行。 需求：在当前的容器中安装了各种组件，期望在其他服务器上也能快速拥有该容器的一切环境。 可以将当前的容器制作为一个镜像，再将该镜像复制到其他服务器，其他服务器再基于镜像运行容器。 镜像制作 将容器保存为一个镜像，通过 commit命令： 1docker commit myredis myredis 第一个mytomcat：容器名称 第二个mytomcat：创建的镜像名称 查看镜像列表是否制作成功： 1docker images 成功制作 备份镜像 通过save命令，在当前目录下保存tar文件： 1docker save -o myredis.tar(生成的文件名) myredis(要备份的镜像名) 通过ll命令查看当前路径下的文件，发现已有myredis.tar文件： 迁移镜像 由于环境限制，只能通过 docker rm命令 把本机的myredis容器删除，从而 使用 docker rmi命令 把上面制作的myredis镜像删除，模拟另一台服务器，实际环境可以把tar文件复制到另一台服务器。 恢复镜像 在当前目录下拿到了tar文件 通过 docker load命令恢复镜像： 1docker load -i myredis.tar(镜像备份的名称) 恢复之后可以查看一下镜像列表： 基于镜像运行容器 创建基于刚才恢复的myredis镜像的容器： 1docker run -di --name&#x3D;myredis -p 6379:6379 myredis 执行之后查看容器列表： 迁移成功。","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"Docker部署Tomcat容器","slug":"Docker4","date":"2020-02-26T11:58:21.000Z","updated":"2020-02-26T12:23:52.774Z","comments":true,"path":"2020/02/26/Docker4/","link":"","permalink":"http://ctrl98.github.io/2020/02/26/Docker4/","excerpt":"","text":"分析 创建容器的时候对容器中的webapps目录（存放web项目的目录）进行目录挂载，发布web项目只需要把项目上传到宿主机的挂载目录即可，tomcat会自动解压包。 拉取Tomcat镜像 拉取镜像的时候不指定版本号，默认下载tomcat最新版的，这里默认就行。 拉取Tomcat镜像： 1docker pull tomcat 等待Pull complete： 查看镜像列表： 1docker images 拉取成功 创建并启动Tomcat容器 执行一下命令进行创建： 1docker run -di --name&#x3D;mytomcat -p 9000:8080 -v &#x2F;usr&#x2F;local&#x2F;mytomcat&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat 属性解释： -di：创建守护式容器 –name：容器名字 -p：端口映射 -v：目录挂载（映射） 注意 创建容器的时候如出现ipv4的警告信息： 修改配置文件： 1vi &#x2F;etc&#x2F;sysctl.conf 在这文件上添加： 1net.ipv4.ip_forward&#x3D;1 重启网络： 1systemctl restart network 查看一下容器列表： 1docker ps 创建成功","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"},{"name":"Tomcat","slug":"容器引擎/Tomcat","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/Tomcat/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"Docker部署mysql Navicat远程连接","slug":"Docker3","date":"2020-02-26T10:53:17.000Z","updated":"2020-02-26T12:01:13.768Z","comments":true,"path":"2020/02/26/Docker3/","link":"","permalink":"http://ctrl98.github.io/2020/02/26/Docker3/","excerpt":"","text":"拉取Mysql5.7镜像 这里拉取的Mysql版本是5.7版本 这里不再作搜索，直接拉取： 1docker pull centos&#x2F;mysql-57-centos7 查看镜像列表： 1docker images -----------------------------------------拉取成功------------------------------------------- 创建并启动Mysql守护式容器 1docker run -di --name&#x3D;mysql5.7 -p 4100:3306 -e MYSQL_ROOT_PASSWORD&#x3D;root centos&#x2F;mysql-57-centos7 -di：守护式容器 –name：容器名称 -p：端口映射，前面的是宿主机，后面是容器的端口 -e：设置密码 centos/mysql-57-centos7：基于哪个镜像创建 镜像创建成功，进入该容器，输入用户名，密码不用输直接回车（我也不是很清楚为什么）： 1docker exec -it mysql5.7 &#x2F;bin&#x2F;bash 想要让外部工具连接Mysql容器，需要给用户权限： 1grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; ; 等待Query OK后，再刷新权限： 1flush privileges; 使用Navicat12工具测试连接 打开软件，点击左上角的连接，选择Mysql -连接名：随意 -主机：宿主机的IP地址 -密码：你创建容器时设置的密码 输入之后点击测试连接： 提示连接成功","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"},{"name":"MySQL","slug":"容器引擎/MySQL","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/MySQL/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"Docker基础知识之镜像与容器","slug":"Docker2","date":"2020-02-26T02:26:40.000Z","updated":"2020-02-27T04:10:33.214Z","comments":true,"path":"2020/02/26/Docker2/","link":"","permalink":"http://ctrl98.github.io/2020/02/26/Docker2/","excerpt":"","text":"废话不多说，前提条件是你的电脑已安装Docker和完成了基本的配置，还没有的话开车送你去Docker基础知识 Docker镜像 容器的运行是建立在镜像基础之上，当然前提是docker服务已启动。 先用 查看镜像 的命令查看一下本机有什么镜像，不出意外应该啥也没有： 1docker images 镜像没有没关系，从共有仓库 拉取镜像 下来就行了，先来搜索你需要拉取的镜像，比如我们想搜索一个centos7的镜像： 1docker search +你要搜索的镜像名称(如：centos7) 搜索出来的结果： 搜索到之后就拉取我们需要的镜像，比如我们拉取一个centos7镜像： 1docker pull centos:7(镜像的名字:版本号)&#x2F;(若不指定版本号，默认拉取最新版本) 过了一小会之后就会提示 Pull complete，说明拉取成功。 这时候我们再回头使用查看镜像的命令就会看到centos7的镜像了： 镜像可以拉取当然也可以删除： 1docker rmi centos(要删除的镜像名或者镜像id) 或者哪天不开心想把全部镜像删了： 1docker rmi &#96;docker images -q&#96; Docker容器 首先我们要知道docker容器分为两种，一种是 交互式容器，一种是 守护式容器，实际开发中一般采用守护式容器。 两者本质区别 交互式容器随容器的创建、启动而启动，随容器的退出而关闭。 守护式容器随容器的创建、启动而启动，但退出容器后，容器依然在后台运行。 上面我们已经拉取了centos7镜像，下面我们先了解一下创建容器的相关命令属性： 属性 说明 -i 表示运行 -t 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去，即分配一个伪终端 –name 为创建容器的名字 -v 表示目录挂载、映射关系 -d 在run后面加上-d参数，则会创建一个守护式容器在后台运行 -p 表示端口映射 -e 表示添加环境变量 查看容器命令（只能查出正在运行的容器）： 1docker ps 查看全部容器命令： 1docker ps -a 查看容器的IP地址： 1docker inspect 容器名字或id 创建一个交互式容器： 1docker run -it --name&#x3D;mycentos7 centos:7 &#x2F;bin&#x2F;bash 执行后会自动进入我们所创建好的容器—mycentos7，使用 ll 命令，然后退出就会回到本机： 创建一个守护式容器： 1docker run -di --name&#x3D;mycentos2 centos:7 创建成功后查看一下容器列表，发现已经在后台运行了： 下面进入该容器看看（exec表示进入的意思）： 1docker exec -it mycentos2 &#x2F;bin&#x2F;bash 可以看出来和交互式容器没什么区别，当我们执行 exit 命令退出该容器后，再查看一下容器列表，发现该容器依旧在后台运行，刚才创建的交互式容器可以通过 docker ps -a命令查看。 停止守护式容器运行： 1docker stop 容器名称或者id 启动容器： 1docker start 容器名称或者id 目录挂载 将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器 创建映射目录 1mkdir &#x2F;usr&#x2F;local&#x2F;test 创建并启动一个守护式容器并挂载test目录： 1docker run -di -v &#x2F;usr&#x2F;local&#x2F;test:&#x2F;usr&#x2F;local&#x2F;test --name&#x3D;mycentos3 centos:7 查看容器列表： 我们在宿主机的test目录下新建一个文件： 1touch test.txt 然后进入 mycentos3容器： 1docker exec -it mycentos3 &#x2F;bin&#x2F;bash 进入test目录下查看文件信息： 1cd &#x2F;usr&#x2F;local&#x2F;test 发现在宿主机创建的test.txt文件也同样被创建在容器中挂载的目录下。 删除容器 1docker rm 容器名称 (注意，正在运行中的容器是无法删除的)","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"Docker基础知识","slug":"Docker1","date":"2020-02-25T07:46:30.000Z","updated":"2020-02-26T09:33:27.998Z","comments":true,"path":"2020/02/25/Docker1/","link":"","permalink":"http://ctrl98.github.io/2020/02/25/Docker1/","excerpt":"","text":"Docker 什么是Docker 百度百科：Docker容器是一个应用容器引擎， 让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 说白了就是把应用（项目）部署到Docker容器中运行，就好像放在真实的物理机上运行一样，不用担心开发环境和生产环境的不一致。 为什么要使用Docker Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多 。 性能很高 ， 系统的开销尽量小 。 环境一致，让开发人员专注于开发。 应用迁移更便捷。 应用更好维护。 应用场景 web应用的自动打包和发布 自动化测试 可持续集成 安装各种组件 Docker的组成部分 Docker客户端：个人电脑安装的docker软件、用来连接操作docker。 Docker守护进程：例如有容器A、镜像1 （容器时基于镜像来运行的,镜像相当于类，容器则是类的实例）。 Docker镜像：从docker仓库中拉去过来，而docker仓库又分共有(docker hub)和私有仓库。 以下以 centOS7 系统为基础环境讲述 卸载旧的版本 如果你的系统中已经有旧版本，那么就卸载他吧， 较旧的 Docker 版本称为 docker 或 docker-engine，卸载后记得要删除相关依赖项。 更新 yum 源： 1sudo yum update 查看已安装软件是否有Docker： 1yum list installed 或者直接查看有没有安装Docker： 1yum list installed | grep docker 如果有的话卸载及相关依赖： 1yum -y remove docker.x86_64#软件名看你自己的 安装Docker社区版(个人和中小型企业基本够用) 安装先安装需要的软件包： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源： 1sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo 如果返回结果如下图表明设置成功： 安装docker： 1sudo yum install -y docker-ce 如果返回结果如下图表明安装成功： 查看docker安装版本： 1docker -v 配置Docker镜像源 创建文件夹： 1mkdir &#x2F;etc&#x2F;docker 使用一下命令编辑内容并创建文件—daemon.json 1cd &#x2F;etc&#x2F;docker 1vi daemon.json 文件内容为： 1&#123;&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]&#125; 镜像也可以用自己的阿里云镜像加速(建议) 编辑完后，按 Esc键，然后按 :，输入 wq，保存文件并退出。 在/etc/docker目录下使用 ll命令查看文件是否创建成功？ Docker基础命令 下面我们来了解一下docker的基础命令 首先是启动docker服务： 1systemctl start docker 停止docker服务： 1systemctl stop docker 查看docker当前状态： 1systemctl status docker 重启docker服务： 1systemctl restart docker 把docker服务设置成开机自动启动： 1systemctl enable docker 到这里说明你已经距离入门还有一大段距离~~~干巴爹斯！！！！","categories":[{"name":"容器引擎","slug":"容器引擎","permalink":"http://ctrl98.github.io/categories/%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://ctrl98.github.io/tags/Docker/"}]},{"title":"第一篇博客文章","slug":"First-Blog","date":"2020-02-25T06:41:43.000Z","updated":"2020-02-26T09:38:25.146Z","comments":true,"path":"2020/02/25/First-Blog/","link":"","permalink":"http://ctrl98.github.io/2020/02/25/First-Blog/","excerpt":"","text":"关于 其实很早就想着有一个属于自己的博客网站，来记录一下自己的学习过程和生活琐事，把自己学习到的知识写下来，算是给自己的一个总结和交代。然后也可以把自己生活上遇到的愉快的、难忘的或是不愉快的事情记录下来，以后当自己翻看自己写过的记录过的东西，也不失为一份回忆。","categories":[{"name":"生活","slug":"生活","permalink":"http://ctrl98.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"个人","slug":"个人","permalink":"http://ctrl98.github.io/tags/%E4%B8%AA%E4%BA%BA/"}]}]}